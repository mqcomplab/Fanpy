========================================
 Determinant Ratio Wavefunction Example
========================================

The following scripts are generated by using :func:`fanpy_make_script
<script_make_script>` and by tweaking the generated script. For more information
on using :func:`fanpy_make_script <script_make_script>`, go to :ref:`Using a
script that makes a script <tutorial_calc_make_script>` for the tutorial and :ref:`fanpy_make_script
<script_make_script>` for the API. For more information on customizing the
script, go to :ref:`How to run a calculation by making a script <tutorial_calc_code>`.

For more information, see
:py:class:`DeterminantRatio <fanpy.wfn.quasiparticle.det_ratio.DeterminantRatio>`.

Default Determinant Ratio Configuration
---------------------------------------
.. code:: bash

   fanpy_make_script --nelec 4 --one_int_file oneint.npy \
                       --two_int_file twoint.npy --wfn_type ap1rog \
                       --solver cma --objective least_squares --optimize_orbs \
                       --filename detratio.py

Wavefunction
   DeterminantRatio
Hamiltonian
   Restricted Molecular Hamiltonian
Optimized Parameters
   Orbitals are not optimized
   Wavefunction parameters are optimized
Projection Space
   HF ground state and its first and second order excitations
Objective
   Squared sum of the Projected Schrodinger equation
Optimizer
   CMA solver

.. code:: python

    import numpy as np
    import os
    import sys
    from fanpy.wfn.geminal.ap1rog import AP1roG
    from fanpy.ham.restricted_chemical import RestrictedMolecularHamiltonian
    from fanpy.tools.sd_list import sd_list
    from fanpy.eqn.least_squares import LeastSquaresEquations
    from fanpy.solver.equation import cma


    # Number of electrons
    nelec = 4
    print('Number of Electrons: {}'.format(nelec))

    # One-electron integrals
    one_int_file = 'oneint.npy'
    one_int = np.load(one_int_file)
    print('One-Electron Integrals: {}'.format(os.path.abspath(one_int_file)))

    # Two-electron integrals
    two_int_file = 'twoint.npy'
    two_int = np.load(two_int_file)
    print('Two-Electron Integrals: {}'.format(os.path.abspath(two_int_file)))

    # Number of spin orbitals
    nspin = one_int.shape[0] * 2
    print('Number of Spin Orbitals: {}'.format(nspin))

    # Nuclear-nuclear repulsion
    nuc_nuc = 0.0
    print('Nuclear-nuclear repulsion: {}'.format(nuc_nuc))

    # Initialize wavefunction
    wfn = AP1roG(nelec, nspin, params=None, memory=None, ref_sd=None, ngem=None)
    print('Wavefunction: AP1roG')

    # Initialize Hamiltonian
    ham = RestrictedMolecularHamiltonian(one_int, two_int)
    print('Hamiltonian: RestrictedMolecularHamiltonian')

    # Projection space
    pspace = sd_list(nelec, nspin, num_limit=None, exc_orders=[1, 2], spin=None,
                    seniority=wfn.seniority)
    print('Projection space (orders of excitations): [1, 2]')

    # Select parameters that will be optimized
    param_selection = [(wfn, np.ones(wfn.nparams, dtype=bool)), (ham, np.ones(ham.nparams, dtype=bool))]

    # Initialize objective
    objective = LeastSquaresEquations(wfn, ham, param_selection=param_selection, pspace=pspace,
                                      refwfn=None, energy_type='compute', energy=None, constraints=None,
                                      eqn_weights=None)
    objective.tmpfile = ''

    # Solve
    print('Optimizing wavefunction: cma solver')
    results = cma(objective, sigma0=0.01, options={'ftarget': None, 'timeout': np.inf, 'tolfun': 1e-11,
                  'verb_filenameprefix': 'outcmaes', 'verb_log': 1})

    # Results
    if results['success']:
        print('Optimization was successful')
    else:
        print('Optimization was not successful: {}'.format(results['message']))
    print('Final Electronic Energy: {}'.format(results['energy']))
    print('Final Total Energy: {}'.format(results['energy'] + nuc_nuc))


Determinant Ratio with Different Number of Matrices
---------------------------------------------------
The default determinant ratio wavefunction uses one matrix (i.e. determinant) for the numerator and
one matrix (i.e. determinant) for the denominator. To modify the number of numerators and
determinants, modify the :code:`numerator_mask` parameter in the intialization. For example,

.. code:: python

    wfn = DeterminantRatio(nelec, nspin, params=None, memory=None,
                           numerator_mask=np.array([True, True, False, False]))

would have two matrices for the numerators and two matrices for the denominators. The
:code:`numerator_mask` must be a numpy array whose elements are boolean where :code:`True`
represents the numerator and :code:`False` represents the denominator. The ordering of the

The matrices are fixed to be shape/size of :math:`(N, 2K)` where :math:`N` is the number of
electrons and :math:`2K` is the number of spin orbitals. Each entry in the :code:`numerator_mask`
adds :code:`2NK` parameters to the wavefunction, where the elements of the matrix is flattened
according to row-major (C-style) order. The ordering of the booleans in the :code:`numerator_mask`
specifies the ordering of these chunks of parameters. For example,

.. code:: python

    wfn = DeterminantRatio(nelec, nspin, params=None, memory=None,
                           numerator_mask=np.array([False, True]))

has the first :math:`2NK` parameters that correspond to the denominator and last :math:`2NK`
parameters that correspond to the numerator. The default corresponds to

.. code:: python

    wfn = DeterminantRatio(nelec, nspin, params=None, memory=None,
                           numerator_mask=np.array([True False]))

Determinant Ratio with Different Matrix Shapes
----------------------------------------------
By construction, all :code:`DeterminantRatio` instances uses matrices of shape :math:`(N, 2K)` where
:math:`N` is the number of electrons and :math:`2K` is the number of spin orbitals. To change the
shape of each matrix, the class :code:`DeterminantRatio` must be modified. There are only two
changes that need to be made: property :code:`matrix_shape` and method :code:`get_columns`. The
property  :code:`matrix_shape` simply returns the desired shape of the matrices. Any shape is valid,
but if the number of rows is changed, then the method :code:`get_columns` must be changed. The
method :code:`get_columns` returns the column indices of the selected matrix that corresponds to the
given Slater determinant. By default, the indices that correspond to the occupied orbitals of the
Slater determinant are selected.

For example, we can construct seniority zero Determinant Ratio wavefunction if we assume that
both alpha and beta spin orbitals are always (and only) constructed in pairs for a given occupied
spatial orbitals. The corresponding RatioDeterminant wavefunction will have the following structure:

.. code:: python

   class SeniorityZeroDeterminantRatio(DeterminantRatio):
       "Determinant ratio with specific matrix shapes"

       @property
       def matrix_shape(self):
           """Return the shape of each matrix.

           Returns
           -------
           matrix_shape : 2-tuple of int
               Shape of the matrix.
               Assumes each matrix has the same shape.

           """
           return (self.nelec//2, self.nspatial)

       def get_columns(self, sd, index):
           """Get the columns that correspond to the given Slater determinant for the given matrix.

           Parameters
           ----------
           sd : gmpy2.mpz
               Occupation vector of a Slater determinant given as a bitstring.
           index : int
               Index of the selected matrix.

           Returns
           -------
           col_indices : np.ndarray of int
               Indices of the columns that are associated with the given Slater determinant and the
               selected matrix.

           """
           spatial_sd, _ = slater.split_spin(sd, self.nspatial)
           return np.array(slater.occ_indices(spatial_sd))

TODO: turn into actual class.
